오전 10:35 2019-04-03

p26
해밍코드로 에러 탐지하고 correction하는 방법. 

해밍코드는 기본적으로 linear block 코드이고, 

예를 들어 G에 대해 m==1010이라면 1010001을 보내겠네
참고로) 앞 정보는 m과 같음.

2^4 == 16개의 코드워드들이 있는데 이중에서 해밍 디스턴스를 비교해야하는데, 16C2로 상당히 시간이 걸리고 피곤함.

그래서 더 쉽게 해밍 디스턴스를 어떻게 구할 수 있을까?
리니어 블럭 코드는 기본적으로 벡터스페이스를 기반으로 한다. 
0과 1로 이루어진 벡터 스페이스. 
실수에서 정의된게 아니고

자아, 자꾸 딴생각하지말고 집중하자.

p25
# 벡터가 4차원이면 기저는 4개 있고, e1~e4임.
<1,1,1,1> == e1 + e2 + e3 + e4 
모든 벡터스페이스를 표준 기저로 표현할 수가 있음.

 v1 == 시그마(1 to 4) ai* ei
+v2 == 시그마(1 to 4) bi* ei
-------------------------------
 v3 == 시그마(1 to 4) (ai+bi)* ei
이때, ai+bi 또한 Z2에 들어감.


임의의 코드워드 두개의 디스턴스를 구하려고 하는데,
어떤 두개의 코드워드를 XOR하는 것은 또 하나의 코드워드가 됨.
--> 코드워드 중에서 가장 디스턴스가 작은 걸 구하는게 결국 전체의 해밍 디스턴스가 된다.

p26
G --> 각 행의 차수 == 3 3 4 3 --> 그게 각각 해밍디스턴스가 되고,
G의 전체 해밍디스턴스는 결국 3이다.
라는 결론이 됨. 
(제대로 집중 못했긴한데, 저번시간 끝에 다 했던 내용임)

+)
message plane --> 차원이 변환되어 전달될때 정해진 공간이 아닌곳에 가있으면 에러

에러를 어떻게 detect?
--> 벡터스페이스 관점에서 직교로 판단 가능.
원점 벡터O와 벡터h가 직교면 즉, O*h == 0이면 같은평면 ㅇㅋ. 아니라면 에러.

p27
이걸로 이제 에러를 디텍트 커렉트하려고 하는데, 
dual 즉, 상보가 되는
--> 직교로 만드는 것이 dual임.

내가 k차수라면 나의 dual은 n-k차수임. 
나의 dual space와는 직교임.

듀얼 서브공간을 구성하는 기저를 구하는 것이 필요. 즉, H를 구하는 것.

G와 H의 관계를 잘 보자.
G의 앞 정행렬, H의 뒤 정행렬은 항등행렬이고, 나머지는 트랜즈포즈 관계임. 
H^T : H의 트랜스포즈된 행렬
아 말로 드럽게 못적는데 그냥 자료 보면 알거임. ㅇㅇ
여기서 핵심은 두 벡터의 내적이 0이 된다는거. 직교니까.

예)
C = <1 0 0 0 1 1 0 >일때, 네번째와 다섯번째가 에러라면
C = <1 0 0 1 0 1 0 >으로 전달 될 것임.
이때, 에러가 발생했다는 걸 알려주는 벡터 e = < 0 0 0 1 1 0 0 >

즉,  e < 1 0 0 0 0 0 0 > 의 의미는 첫번째 비트가 에러다 라는 뜻.

H에서 첫번째 비트에 에러가 발생하면 
1
1
0
그게 코드워드가 뭐든간에 관계없이 1비트 에러를 correct할 수 있음.

p43
해밍코드 예제
(강의자료 다시 받을것)
3. 1101000
4. 1101101을 H^T에 곱하면 됨. 0이면 에러가 없고 0이아니면 에러가있음.
  --> 네번째 비트에 에러가 있음. 
5. 1100000를 곱하니까 101가 나와서 에러가 있음을 알 수 있음.
근데 1 0 1은 H에서 네번째와 패턴이 같으니까 거기가 에러.
따라서 원래 데이터는 1101000일 것이다. 

+) 2비트 이상의 에러에 대해서 correction이 가능한가? 불가능
 
리던던시 비율을 보니까 m이 커질수록 유리해짐.

p32
알아서 읽어봐.

p29-30 사이클릭은 그냥 안하고 넘어감.

p31
어떤 기술을 사용할지 말지 확률적으로 평가하는것은 매우 중요한 문제임.

비트에서 에러가 발생할 확률이 p일때, 
1. k비트중 한 비트 이상이 에러가 나면 에러라고 간주. 이때의 확률은?
  답 : 1 - (1-p)^k

2. throughput(처리율), goodput(유효한 처리율)
이 두말은 다른 말임.
예를들어,
처리율은 단위시간당 백개의 물건을 생산 --> 100/1hour 
그러나 이중에서 10개는 불량 --> 90/hour == goodput

에러가 발생하는것은 제대로 간다고 간주하지않음.
그럼 goodput의 확률은? (1-p)^k : 제대로 갈 확률.

에러가 날 확률이 1퍼센트임에도 불구하고 진짜 에러가 난다해야하나 암튼 에러확률은 약 28프로임.
심각.
해결해야함.
(7, 4, 1) : 4에다가 3비트를 추가해서 총 7비트를 보내는데 에러가 날 수 있음.
최종적으로의 에러율은? 
아 집중안하나 
에러가 발생하지 않을 확률 == 1 - (1 - p)^7 - 7C1*p*(1 - p)^6

이 채널의 평균 유효처리율은 얼마인가? 함정임.
유효처리율은 4/7을 곱해야함. 7비트 중에 3비트는 redundancy로 덧붙인거니까 내가 일을 한 게 아님

==> 처리율이랑 비교해서 유효처리율이 더크다면 안하는게 낫다라고 판단해야함.
그래서 Code A, B, C 중에 어느 것을 써야하는 지 계산해야함.
그러니까 매틀랩을 써야함.












