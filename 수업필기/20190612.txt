오전 10:28 2019-06-12

기말 6409 10:30 ~ 12:45

10장. Broadcasting in Multi-Hop Wireless Networks

차량 몇중충돌 대참사같은거 들어본적있지?
그래서 V2V라는 기술을 도입해서 이거없으면 차 못팔도록 기술 장벽을 높임.
이게 뭐냐면 사고가 났으면 주변 차량들에 전파함.
단 전파 거리에 한계가 있어서 multi-hop으로 전달해야함.

multi-hop : 직접 전달 못하고, 릴레이로 전달하는건데
효율적으로 처리하지 못하면 문제가 생김.

p2
불필요한 정보를 제거해서 필요한 정보만 남김.
여기있는건 모든 점을 다지나서 원래자리로 돌아오는 오일러 한붓그리기 문제임.

p3
수많은 graph problem들이 있고, 네트워크에서 중요한 문제임.
- graph coloring
	앞에서 배운 셀도 이 문제임
이런거 이미 다배워서 아는거고,

- Flow Network
	군수물자 나르는데 얼마나 효율적으로 나를수 있는지에 대한 문제.
# 알고리즘도 열심히 잘 해야 네트워크를 잘 할 수 있음.

p5
shortest path와 관련된 알고리즘. 

p6
spanning tree : 모든 vertex를 다 포함하되, 엣지의 합이 최소가 되도록 하는 트리
tree : 사이클이 없는 그래프.
다음의 두가지 종류의 알고리즘이 있음.

# 알고리즘 풀이보다는 어떤 알고리즘의 종류가 있는지 먼저 보는 것이 중요.

p7
크루스칼 알고리즘.
어떤 알고리즘인지 이해해야함.

p8
프림 알고리즘

p9
오늘의 메인.
다음과 같은 무선 네트웤이 있음.
여기서 네트웤이 의미하는것?
A가 transmission하면 BCD만 받을 수 있음. 다른 것들은 안됨.
이때 A의 정보를 모두에게 전달하려면?
Flooding : 홍수. 다른 녀석들로부터 받으면 또 전달.
Blind Flooding을 하게 됨. 
이미 받은애들은 무시하고, 새로 받은 애들은 받아서 다른 애들한테 전달함.

지금 무선 통신에게 이런 기법들을 쓰는데, 
그림에서보면 여섯번의 전송이 일어남.

근데, Optional Flooding을하게 되면 한번만 하면되는데 위의 방식은 비효율적.
Blind Flooding은 배터리도 많이 쓰고, 안정성도 떨어짐.
우리는 Optional을 하는 것이 목표임.

p10
효과적인 Forwarding Tree를 먼저 만들어야함.
그 포워딩 트리는 스패닝 트리여야함.
초록색 노드는 받고 나서 다시 포워드하는 노드를 의미.

왼쪽과 오른쪽의 차이는?
왼쪽이 초록색이 더 적음. 
그러나 hop은 오른쪽이 더 적음.
둘 다 장점이 있단 말이지.
그래서 그래프 문제에서는 최적화를 위한 명확한 목표가 있어야함.

여기서의 목표는 포워딩 워드를 최소화하는것.
따라서 왼쪽이 답임.

p11
MCDS알고리즘. 
주어진 그래프에서 MCDS 문제는 
최소의 subset S를 구하는 문제인데 전체에서 S를 뺀 나머지 노드는 모두 S와 인접해있어야함.

p12
이걸 휴리스틱으로 풀어갈건데,
알고리즘을 네트웤 문제에 적용하는 문제하는데 
지금까지 해왔던 문제들은 대부분 그래프전체를 아는 경우(Centralized)였음.

근데 우리가 해야할건 distributed 알고리즘임.

1.Centralized 와 2.Distributed의 차이점?
2는 전송 시점을 각 노드가 결정,
1은 전송 시점을 하나가 다 결정.

지금 말하는 건 distributed 알고리즘이다?(중간에 딴생각)

p14
distributed 알고리즘은 각자가 포워딩할지말지를 스스로 결정하는데 로컬 인포메이션이 필요함.
각 노드는 자신의 이웃을 알고 있음.
예를 들어, B는 자신의 이웃이 A, E, C라고 알고 있다고 가정.
B의 이웃들 중에서, A에 의해서 서비스 된것들과 A를 뺴고 났을때, 공집합이 아닐 경우 신호를 보낸다.

p13
왼쪽,
N(v) = {a,b,c,d}
N(u) = {c,d}
v로 부터 정보를 받은 u는 전송할 필요가 없음.

반면 오른쪽은 전송.
이런걸 self Pruning이라고 함.

다시 p14
셀프 푸르닝은 당연히 옵티멀이 아님.
셀프 푸르닝 포워딩 노드는 A, B, C, D, E, F, G
반면, 옵티멀 포워딩 노드는 A, B, E, G

이제 Dominant Pruning 할건데 5분 쉼.

p15
# Prun : 가지치기.
Dominant Pruning : 패킷을 보내는 송신자가 결정함. self가 아님.
2-hop neighbor. 정보가 셀프보다 더 많음. 
(A의 이웃 뿐만 아니라 A이웃의 이웃까지 알고있음)
그래서 그 정보를 이용해서 A가 A의 이웃이 그 이웃에 보낼지말지를 결정.

그림에서 u가 센더로 데이터를 전송할 것임.
자신의 네이버로 전송을 하는데 N(N(u))가 커버가 되어야함. 
이말을 이해해야하는데 또 딴생각함. 함넝ㄹ;미ㅏㄴ ㅓㅇㄹ;ㅓㄹ
목표는 자신의 2-hop 네이버를 다 커버할 수 있도록.

p16
B의 입장에서는 자신의 2-hop 네이버가 
아 자꾸 딴생각한다. 고만해라 좀.
암튼 답은 A,B,D,E,G
여하튼 이건

p17
패킷 포워딩 되는 숫자가 크면 클수록 안좋음.

여기까지가 p9의 Broadcast in Ad-Hoc network였음.
** 마지막 두 알고리즘에 대해 이해를 잘 해야함.
* 프루닝 그래프 그리는거 나옴.
* 홈웤, 퀴즈 다 보고, 강의자료 
이 뒤에는 시간 부족으로 시험범위 ㄴㄴ




