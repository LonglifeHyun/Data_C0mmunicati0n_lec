오전 10:34 2019-04-15

Required Precision is 4. : 소수점 아래 네자리만 보겠다. 반올림 ㄴㄴ

HW4 에서 CRC문제가 모호했음. 추가로 덧붙여서 생각하면 다른 정답이 있을수도 있음.
그러나 중간고사에서는 그런 모호함 없을것임.


자, 지금까지 배운걸 정리를 하면,
ARQ : Retransmission에 기반한 packet레벨 에러 복원 
1) stop and wait  -->  처리율 == 1/RTT
2) sliding window  -->  처리율 == W/RTT

time out : 성능에 아주 밀접한 영향을 미침.
delay를 다 계산 할 수 있어야 함. 

p22
새로운 거 배움.

Flow Control(흐름 제어) & Congestion Control(혼잡 제어)
둘 다 sender를 관리

흐름제어
 리시버가 받는 것보다 더많은 일을 주면 안됨. --> 결국 데이터가 소실될 가능성이 있음.
 그래서 overruning 하지 않도록 제어함.

혼잡제어
 이 네트웤은 다른 사람들도 같이 씀. 여러사람이 동시에 쓰게 되면 네트웤의 성능이 떨어짐.
 네트웤은 실제로 여러개의 링크로 구성되어 있는데 
 이 링크가 congest된다는 것은 마찬가지로 버퍼에 꽉차서 결국 데이터 소실 된다는 말임.
 그래서 네트웤이 overrunning하지 않도록 센더를 제어.

두개의 차이를 명확히 구분해야함.
공통점은 transmission rate/speed를 조절해야한다는 거.
그래서 우리가 센더의 전송속도를 조절하는 것을 좀 더 큰 의미로 흐름제어라고 씀.

사실 넓은 의미의 흐름제어는 둘다를 포함하는 말임.

TCP 는 플로우, 컨제션을 둘 다 지원, 그러나 UDP는 지원하지 않음.

p23
일단은 두개의 차이를 지원하는게 먼저.

이제,
Rate Based Approach : rate기반의 접근법.
 속도조절의 관점에서는 보다 직관적이고 명확하게 보임. 그러나 implement하는 것이 쉽지 않음.
 코딩을 하기 위해서는 일반적으로는 timer가 필요. --> 복잡해지고 부하가 커짐. 타임을 계속 체크해야하므로.
 
**window Based Approach : window기반의 접근법.
 상당수의 프로토콜들이 채택하고 있는 방식. 

sliding window protocol
 에러 컨트롤이랑 흐름제어 둘 다 할 수 있음.
 W를 조절해서. 

p24
TCP
윈도우 사이즈는 매우 중요한 요소가 됨.

그림을 보고 해석을 자세히 해보자. 이해를 할 수 있어야 함.
빨간색은 흐름 제어. 파란색은 혼잡 제어.
흐름제어는 Explicit(명시적)인 피드백이 있고, 
혼잡 제어는 명시적인 피드백이 없음.
TCP에서 말하는 거임.

Closed Loop Control
예를 들어 보일러에 연료를 집어넣으면서 온도가 올라가는 것을 보면서 계속 하는거.

Opened Loop Control
피드백 없이 그냥 주변상황보고 하는거.

# AW(advertise Window) : 리시버가 나한테 광고하는거.

실질적으로 윈도우는 두개. 
--> TCP window == Min(AW, CW)

p25
전에 보여주셨던 wireshark를 다시 보여주심.
그 중에 TCP의 헤더 부분이 p25의 그림처럼 생김.

음.. 잘 못들음 궁금하면 녹음 듣던가

송신자가 TCP로 보내면 수신자는 ACK를 보낼건데,
1번 패킷 잘 받았어이런거 보내야하는데 APPlication이 읽어가지 않으면 보낼 수가 없음.
최대 5개까지 더 받을수있는데 더 보내면 데이터 로스.
ACK를 보내는 시점에서 수신자가 추가로 수신가능한 데이터 양. 즉, 버퍼의 사이즈를 알려주면 over할 일이 없음.

p28
참고

서큘러 큐 : 버퍼사이즈는 한정이 되어 있고 다쓰면 다시 앞으로 돌아옴.

센더 입장에서 한번 보면, application이 어디까지 썼으면 거기까지를 유지하고있어야함. 
그리고 그 중에서 일부를 전송을 했다면, 앞으로 쓸 걸 위해서 버퍼 비워도 되는가? 
절대 안됨. 제대로 가기 전엔 안됨. 
재전송 요구가 있을 수도 있기 때문.
즉, ACK를 받으면 그리고 그 ACK가 일정부분까지 오면 버퍼를 비우는 것(free)이 가능해짐.
--> 세개의 포인트를 유지해야함. 
이 때, ACK이후로 보낸게 AW보다 작아야 함.
그래서 AW보다 작다면 더 보낼 수 있는 거고, 이 그림이 그걸 의미하는 것임.

자, 이제 오른쪽 그림.
쭈욱 썼는데 빈공간이 생김. 뭘 의미하는 걸까? 패킷이 로스가 되었다는 말.
(4번이 안왔는데 5번이 온 경우같은거)
가장 최근에 받은건 Rcvd까지이지만 ACK를 실제로 보내야하는건 Expected까지임.

개념적으로, 내가 가지고 있는 여유 버퍼를 알려줄 수 있다?

p29
그래서 sending application이 이렇게 있는데, 블라블라블라
이해 ㄱㄱ
사실 이런 디테일까지 하려고 하는건 아님. 

앞에서의 개념. 윈도우 개념. 이게 중요하고 많이쓰이고 핵심이다를 말하려고 한 것임










