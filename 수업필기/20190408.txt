오전 10:33 2019-04-08

4/17 중간고사 12:00 ~ 1:15 전산실에서. 매트랩 사용 (HW3_4같은 경우)
범위는 5장 ARQ까지.
15일까지 계속 수업.
5장에 대한 과제는 없음

매트랩 사용 (HW3_4같은 경우)
람다 = 6/min --> 1/10sec, t = 1/6min
--> 람다*t == 1
포아송 식에 대입 계산은 알아서 ㅇㅇ

* matlab이라 r언어 사용법 숙지해두기.
효율적 : sum(factorial(0:4))
--> 시간 내에 계산 해내야함.

[4장으로 돌아와서]
해밍으로 correct까지 하는거 했었음. 이어서 성능분석까지 했음. 

p33
이런 그림을 해석하는 것이 매우 중요함.

세로축 : 에러확률 --> 위로갈수록 높아짐. 즉, 밑으로 갈수록 좋음
가로축 : data bit Energy / noise 즉, 보내려고 하는 데이터의 비트가 노이즈보다 커야함을 뜻함.
교수님이 말씀하시는게 저멀리서는 잘 안들릴거잖아.
그니까 수신신호를 세게 해야 에러확률이 떨어짐.
수신신호를 세게 하려면?
크게 말하라고 하겠지. 즉, 에너지가 필요함.
무선에서는 배터리가 중요함. 근데 두배 세게 보내려면 파워가 두배로 쓰임.

오른쪽으로 갈수록 에너지가 더 많이 필요하다는 것임.

rate 1/2 coding
: 데이터 50퍼센트 추가로 보낸다는 것. --> 그러나 에너지가 덜쓰이니까 coding으로 얻는 gain이 크다는거. 

아아아 정리.
성능은 에러확률이 낮을 수록 좋은거고,
에너지관점에서는 왼쪽으로 갈수록 에너지를 덜쓰니까 더 좋은거고.
근데 극왼쪽을 보면 코딩하는게 코딩 안하는거보다 에러확률이 더높아서 안좋음. --> 코딩이 의미가 없다는 말임.
근데 교점 이후로는 의미가 있다는 거지. ㅇㅇ

p34
지금 7,4 해밍코드를 쓸건데, 1비트까지 correct 가능.
에러 발생확률 == 1/7 
7비트마다 한비트만 에러가 나면 correct가능.
그러나, 뭉쳐서 에러가 나면 correct불가능. 그러나 평균으로 보면 1/7임.

즉, 에러가 발생하는 패턴에 따라, 같은 확률이더라도 burst error는 훨씬 하드한 error임. 
근데 실제에선 이런 에러가 많다는게 문제임. 
특히 무선 통신에서는 independent한거보다 burst한 에러가 훨씬 많음.
--> 완화방법 : Interleaving

밑에)
(4,3)코드를 쓰고 1비트를 correct할 수 있다고 가정하자.
burst일 경우에 error correction이 불가하니까
보내는 순서를 조절해서 보내면 error correction이 가능함. --> 성능이 좋아짐

비슷한것) os 스케쥴링할때, task스케쥴링을 달리하면 평균 reponse time 이 달라짐. 

interleaving의 단점? delay가 늘어남. 패킷을 복원하기 위해서 끝까지 받아야 하므로.

+) 야구장에서 라디오, 혹은 스마트폰으로 방송을 보려고 할 때,
동일한 장소에서 동일한 컨텐츠에 대해 너무 많은 사람들이 보려고함
방법 1. 여러개의 one-to-one 커뮤니케이션
	사용자 수가 늘어가면 필요한 자원의 수는 linear하게 늘어남
방법 2. 패킷 하나로 모두를 커버
	이론상으로는 하나의 자원으로도 커버가 가능하므로 추가 자원이 필요가 없음.
	문제는 패킷이 여러가지 요인으로 인해 loss가 발생
	어떤사람한테는 수신이 안됨.
--> 해결방법 retransmission과 FEC(추가 데이터)가 있었음.
 
p38
 근데 이제, 비트 레벨이 아니라, 패킷 레벨로 보냄. 
 수신자가 k개 이상만 받으면 n개의 encoded 코드를 복구가능하다는게 있음.
 보다 강인해질수 있음.
 
p40
이 코드에서 k, n의 의미를 알아야함. 
p41
wifi-broadcast를 하는데 패킷이 다 안왔을때 복구하는걸 졸업과제로 했음을 보여줌.

FEC이런게 어떻게 짜여졌는가는 알필요없지만 n,k 개념은 알아야 함.

p35
채널 코딩
대표학자 : 샤논

p36
오른쪽 끝으로 가서 transmit됨을 보여줌. 
안배운 것(modulation)도 있지만 대부분 배움.
중간에 동기화 하는거도 안배우긴했는데 1계층에서 modulation이랑 같이 배울 예정.

[5장_ARQ시작]

1장. layerd 구조
2. 멀티플렉싱
3. 맥
4. 에러 디텍션 앤 커렉션 - 에러에 관련된 거

5장. repeat request <-- retransmission과 비슷.

p4
ARQ : 패킷 레벨에서의 retransmission으로 복구

p6
detect하는 방법 첫번째.
stop and wait 
패킷을 보냈는데 loss가 날 수 있는 상황.

위에 sender에서 밑에 receiver에게 패킷을 보내는데 시간이 걸려서 보냄.(대각선)
그리고 나면 receiver에서 ACK를 보냄. 
sender는 ACK가 오면 다음 패킷을 보냄.
근데 중간에 loss됨. detect해야하는데 어떻게 하지?
기다렸는데도 ACK를 안보냄. 

예를 들어 치킨 심부름 보냈는데, 두시간이 지나도 안와. 

여기서 새로운 요소. timeout
timeout이 너무 길면 자원이 낭비됨.
그렇다고 또 너무 짧으면 불필요한 retransmission이 발생.
에크가 뒤늦게 왔지만 이미 재전송한 상태 --> 중복.
근데 이 뒤늦게 온 에크를 재전송하고 보낸 애의 결과라고 생각하고 다른 패킷을 보내버림. (보내지 말았어야하는데)

밑에그림을 보면,
에크를 보냈는데, 중간에 에크가 loss
duplication이 발생.

암튼, 정리하자면 보내지말아야할때 보내고, 보내야할때 안보내고 이런경우가 자꾸 생기니까 
SEQ, AEQ가 추가 되어서 이제 패킷을 보낼때 번호도 함께 보냄. 





















