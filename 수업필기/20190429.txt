오전 10:35 2019-04-29

Architecture.
구조라고 하는게 너무 큰 틀이다보니 잘 보이지 않아서 중요치 않게 생각하는 사람이 있다.
그러나 그게 아니고 큰 틀은 아주 중요한 개념이다.

예를 들어 언어간의 번역을 위해서는 translater를 만들어야 한다.
일대일로 매칭되는 trans접근 방식이 있고,
esperanto(국제표준언어)를 기준으로 하는 trans접근 방식이 있다.
위의 방식은 모든 언어에 대해 변환 방식이있어야함.
그러나 밑의 방식은 새로운 언어가 추가되더라도 표준언어로만 바꾸고 에서 바꿀줄만 알면 됨.

이런게 구조를 알아야 가능한 것임. 이게 컴퓨터 사이언스이고.
공통의 logical한 표준이 있고 다른 것에 영향을 미치지 않고 하나만 들어가면 됨.

예전에는 프로그램 만드는 일이 매우 어려운 일이었음.
모든 프린트회사에 맞춰서 다 다르게 프로그래밍을 했어야 했었기 때문임.
요즘은 이렇게 하지 않고, 표준에 대해서만 프로그래밍해서 보다 간단한 일이 됨.
이때의 표준 : common logical interface
--> Device Driver : 장치를 이용하기 위한 os 레벨의 software
새로운 회사의 프린트기가 온다해도 디바이스 드라이버만 있으면 되지. 그거에 맞춰서 다시 짤 필요가 없음

이 원리가 인터넷의 기반으로도 쓰이고 있음.(Architecture의 중요성!)

통신에서는 두가지 전달해야할 것이 있음
1. Data
2. Control(Signal)

예를 들어, 전화를 할 때 뚜루루루하는 신호음을 기다림. 그 신호음 == 전화해도 된다.
그다음 연결되고나면 말함(데이터 전달)

p11
(써보자)
In-Band Signaling.
Out-of-Band Signaling.

아까 말했듯이 두개가 있고, source와 destination이 있음.
데이터가 가는 길이있고, 컨트롤이 가는길이있음.
근데 이 두개가 같이 가면 In-Band라고 함.
길이 따로 있으면 Out-of-Band라고 함.

그래서 최초의 망을 만들때는 같이 가는 길을 많이 만들어놨었음.
최초에는 스위치가 있으면 하나의 링크로 데이터와 컨트롤이 같이 가는 구조였음.
근데 만약에 링크 하나가 문제가 생기면 전체가 문제가 생겼음. 그래서 
문제가 생기지 않게 하려면 비용이 많이 생겼음.
p11의 그림을 보면 위와 아래로 구분되는데 위는 Control길이었고, control만을 위한 별도의 네트워크가 있음.
아래는 데이터가 가는 길이고.

한마디로 데이터 네트웤과 시그널 네트웤을 분리해서 reliable하고 security하게 만듦.
--> 시그널 네트웤을 지능망이라고 하고 혹시 데이터망에 문제가 생기더라도 지능망을 통해 전달 가능하게 함.
이게 2000년대의 변화임.

그다음 새로운 변화
p12의 아래 그림. 
스위치로 하나의 디바이스로 엮었는데, 밑에는 별도의 디바이스로 만듦.
즉, 제어와 데이터를 머신 레벨에서도 구분.
이런구조를 soft switch라고 함.
데이터를 고속으로 보내는 것과 제어를 지능적으로 하는 것을 분리. 
이걸 잘 만드는 회사가 하웨이임.

근데 이거는 표준화할 수가 없음.

1.데이터는 속도, 성능이 중요하다면 (HW oriented 장비)
2.제어는 안정성, 편의성 등이 중요함. (SW oriented 장비)

그래서 1은 글로벌한 대기업. 2는 중견의 소프트웨어기업.

암튼 소프트 스위치는 이 두개를 분리해버리는 것.

p13
--> Cellulat Network
그림을 보기가 어려운데, 하나하나 잘 보라우
mobile station == 폰
Base Station == 기지국 (기지국 장비가 폰이랑 연결하는데, 이 기지국 장비를 삼성이나 하웨이같은 대기업이 만든다고)
이동통신망은 다른데로 잘 옯겨다니잖아? 그걸 handover라고함.
외부에 누가 통신을 하다가 이동통신망이 옮겨지면 위치를 잡아서 바꿔서 다시 통신을 해야함.
다시, 그림 HLR같이 소프트웨어제어가 많은 장비들은 네트워크 시스템에 주로 다있음.
이건 우리같은 소프트웨어 만드는 사람들이 만듦.

사실 여기는 시험에 낼 것도 별로 없음. 
**위에(p12) 아키텍쳐의 이름이나 둘의 차이에 대해서정도


UDP vs TCP는 일단 skip

p17(자료 수정전임)
[Routing]먼저 할 것임

forwarding : 목적지를 바탕으로 포워딩 테이블을 바탕으로 어디로 나갈지 정하는 거.
routing : 포워딩/라우팅 테이블을 만드는 것.
이 둘을 합쳐서 큰의미에서 Routing이라고 하기도 함.

cmd에서 route라고 하는 명령어가 있는데 라우팅 테이블을 조작할 수 있음.

Forwarding Algorithm
1. 목적지 IP 주소를 알아낸다. (IP 주소는 A.B.C.D 와 같은 형태를 가짐(0 < A~B <255))
2. 포워딩 테이블/ 라우팅 테이블에 대해서,
	 목적주소와 Netmask를 &연산해라. 
# mask : ex) 111100000 와 &시키면 앞의 네비트는 그대로 나오고 뒤에는 다 사라짐.
	그 다음 모든 엔트리에 관해서 match가 되는지 확임. match는 1개 이상 나올수 있음.
	매치되는 건 항상 적어도 한개는 있음 --> default gateway
3. 매치된 엔트리 중 prefix가 가장 긴 것에 대해(Finally match)
	그 것에 해당하는 인터페이스로 자기 자신이 직접 보낼수 있다.(연결되어 있으므로)

이 목적지에 관해서 어디에 갈 것인지 결정하는게 포워딩이고
그거에 대해 테이블을 만드는게 라우팅임.
우리는 라우팅에 더 집중할 것임.
결국 그래프에서 shortest path algorithm임.

근데, 네트웤에서 중요한건 단순히 알고리즘이 아님.
같은 알고리즘이라도 그냥 그래프에서 쇼티스트 패쓰랑 라우팅에서는 조금 다름.


p20(써보자)
< 2 Basic Routing Architectures > 
1. Distance-Vector
2. Link-State

p21
라우팅에서 핵심은 현재 local 정보를 가지고 있는데 어떻게 하면 전체 정보(그래프 전체)를 얻어올 것인가 하는 것임.

예제를 보자. 
Link먼저.
최초의 A입장에서 자신의 local link state를 다른 모든 노드에 전달하고 교환함. (Broadcast)
결국에는 global link satate를 알게 될 것임.
그다음에 다익스트라 알고리즘을 적용하는 것이 Link State알고리즘임.

distance vector.
거리를 유지하면서 next-hop(직접 갈수 있느냐)에 대한 정보를 얻음.
표 보면 이해갈 것임.

각각의 노드들은 distance vector를 가지고 있는데, 
모든 노드와 교환하는 것이 아니라 이웃 노드에 관해서만 정보 교환.
A가 B로부터 받았다고 하자. 그 순간 하나하나 비교를 할 것임.
E에 대해서 비교를 함. 
A에서는 E로 가는 법을 모름. 근데, B정보를 보니까 B는 E까지 3이면 되네?
그래서 A는 B를 거쳐서 E로 가는 법을 알게됨.
거리는 5 + 3 으로 8.

그리고 C의 정보를 받음.
근데 C는 B까지 2만큼의 거리를 가지고 있음.
A입장에서는 B로 바로가면 5만큼 걸리는데 C를 통해서 가는 것이 더 이득인셈임.
그래서 C를 받는 순간 A->B의 distance는 4, Next-Hop은 C로 업데이트 됨.

업데이트가 한번에 되는 것이 아니고 점차적으로 됨.

정리.
크게 두가지 방식이 있음.
상대적으로 Link-state방식은 쉬움.
Distance-vector는 이웃 라우터하고만 주고받으면서 업데이트 해가는데, 
이 알고리즘 그 자체를 distributed bellman-ford라고 함



