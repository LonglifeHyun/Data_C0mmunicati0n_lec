2019.04.01

< 지금 하고 있는 내용 정리 >
에러라고 하는건 보낸거랑 받은게 다른것인데,
크게 두가지 종류가 있었음. 
1) BSC : 비트의 값이 바뀐것
2) BEC : 패킷이 사라짐

이 중에서 1)에 지금 배우고 있는 중임.
에러 극복해야 하기 위해서는 detect를 먼저 한 뒤에 recovery해야함.
(모든 문제가 그러함 일단 detect부터, 그 후에 recovery)
또 다른 에러 대처법으로는 prevention이 있음.
그리고 그 사이에 Avoidence? 가 있음. 완벽하게 예방은 불가하지만 문제가 발생할거같다면 회피하는 방법.

(비유)
차 사고로 예를 들면
Avoidence는 감시카메라 같은거.

근데 통신에서 에러를 prevention을 하는것은 불가능함.
그래서 detection & recovery이랑 Avoidence에 집중해야함.

가장 기본이 되는 문제 해결의 원리 : divdie and conquer

recovery관점에서 해결하는 방법
1) retransmission
2) correction (+ Redandancy(추가 데이터)를 보내서 복구 가능하도록 함)

# RAID 시스템 : 하드디스크의 속도를 높일 뿐만 아니라, 안정성을 높임.
	부가적으로 redandance공간에 정보를 넣고 싶음. X라는 공간에 문제가 생기면 복구가능.
	근데, Y공간에 문제가 생기면 복구 불가능.
	이를 해결하기 위해 X XOR Y 결과를 저장. 
	--> 둘다 복구 가능. ( (X XOR Y) XOR Y == Y )

그래서 복구에는 
1) retransmission
	feedback을 받아서 재전송. 단, 시간이 걸림.
2) FEC(Forward Ech Correction)
	sender가 receiver가 X, Y, X XOR Y 세개의 데이터를 보냈을 때, 세개중 두개만 받아도 복구가 가능함.
	시간적인 관점(real time)에서는 이 방법이 더좋음.

BSC 에러 감지를 수학적으로 봤을 때,
k bits data + (n-k) bits redandency ==> n bits codewords

codewords는 k비트의 데이터에 일대일 대응되는 데이터이므로 2^k종류의 코드워드만이 legal data임.
이 과정에서 모든 데이터를 detect할 수는 없다는 것도 이해해야함.

< 추가 데이터 만드는 방법 >
1) parity (even / odd)
	만약 even에서, 10110라는 데이터가 오면 확실히 에러가 있다고 말할 수 있지만,
		10100이라는 데이터가 오면 에러가 있다고 명확히 얘기할 수가 없음.
		(만약 1비트만이 에러라고 제약을 두면 에러여부를 말할 수 있음) 
2) Hamming Distance
	서로 다른 비트의 수를 구해서 최소의 차이를 말함.
	여기서, legal vs illegal의 얘기가 나와야 하고,
	몇비트 에러가 났을때 detect를 할 수 있는지, 또 correction할 수 있는지 이해해야함.
	* Hamming Distance와 error correction과의 관계
3) (Galois) Field
	집합에 대해서 여섯가지 속성들을 만족해야함.
	(Closure, Associativity, Identity, Inverse, Commutative, Distributive)
	--> 갈로아 필드 == 유한 필드
	==> (확장) Polynomial GF2(x)
	이걸 통해 우리는 우리가 다루는 바이너리 코드들을 자유자재로 사칙연산할수 있게됨.
	p(x)*q(x) + r(x)

  ==>  CRC(Cyclic Redundancy Check) : 데이터 correction을 위한 추가 데이터.
	전송하는 데이터 T(x)를 만들 수 있고, 항상 p(x)로 나누어 떨어지게 됨.
	(만일 p(x)로 나누어 떨어지지 않는다면 에러고)
=============================================================================================
p22
위에 내용 외울 필요는 없음. 그냥 CRC의 특성을 말하는 것임.
CRC-16에 대해서는 문제 내실 것임. 계산 할 수 있어야 함.

지금 CRC를 하고 있는데 에러 감지를 위해 기본적으로 많이 쓰임.

Error Correcting Code에 대해 설명할 건데 두가지가 있음.
1) Block Codes 
	지금까지 한거, 주어진 데이터가 있으면 그걸로 판단하는거.
	단, 현재 메시지 블럭으로 부터 만들어냄.
2) Convolutional Codes
	현재 메시지 블럭 뿐만이 아니라 이전의 메시지 블럭으로까지 만들어냄.
	좀 더 어려움.
# sequential socket은 state이 있고	--> Convolutional과 유사
 combinational 오직 input으로만 		--> Block과 유사

p24
벡터 스페이스. 선형 대수 시간에 함.
벡터 스페이스는 필드 상에서 정의됨. 교환 결합 분배 항등원 모든 걸 다 만족하면 벡터 스페이스라고 정의함.
벡터에서는 차원이라는 게 있음( 3차원 벡터다 라고 하면 공간임. )

벡터 공간의 차원(Dimension)과 기저(Bases) 개념에서
Q1 - A1. n차원
기본 벡터(기저)로 모든 벡터를 표현 할 수 있음.
ex) v=(3,2,1) == 3*e1 + 2*e2 + 1*e3
단, 기저가 e만 있는 것은 아님
단, 기저는 n차원에 대해서 최소 n개가 필요.

벡터에 행렬을 곱해서 변환을 시켜줌.
이 변환은 회전일 수도 대칭일 수도 있음.
rank : 가로든, 세로든 독립적인 것인 것. 
ex)
1 1 1
0 1 1		--> Rank == 2
1 0 0
(이해 잘 안되면 책 찾아보자)

rank와 벡터공간의 변형과의 관계 rank에 의해 변형 결과 벡터는 rank의 차수를 가짐.
즉, 3차원 공간의 모든 벡터들이 1차원으로 갈 수 있다는 것임.

--> subspace(부공간)

p25
집합이 있고, 집합이 있는데 벡터 스페이스임.
Z2 = {0,1} --> 사칙 연산이 문제없이 된다는 것을 알고 있음.

Z2^n의 기저는 n차원.

0111101 → (0, 1, 1, 1, 1, 0, 1)
: 벡터스페이스로 생각하면 벡터공간상에 7차원상의 벡터로 생각할 수도 있음.

linear block code라고 하는 것은
(강의자료 오타있음 2^k codeword가 아니라 2^n codeword임)
dimension(차원)을 유지한다는 말인거같은데 제대로 못들음.

p26
예)
4차원 --> 7차원
G는 4차원임. 이 G의 차원을 유지한채로 ..	--> linearity가 유지됨.
보다 큰 차원으로 가는데 이때, linerarity
이부분 제대로 못들음. 좀 생각해보자.

이때, subspace가 우리가 원하는 특성을 가지고 있으면 error correction에 효과적일 것임.
0000 ~ 1111 : 16가지의 코드워드를 보내려고 하면
2^4개의 legal codeword가 나옴.
Hamming Distance를 알아야 하는데(이걸로 나중에 뭐한다고 했음),
이건 원래 모든 코드워드들 사이에 해밍거리를 구해서 최소를 골라내야하는데
16C2는 너무 큰 값으로 일일히 다 계산하고 있을 수 없음.
--> min{}어쩌고의 특수한 기호가 있음.
	: codeword와 codeword를 더해도 codeword가 되어야 함. (벡터스페이스의 정의에 의해서)
	  따라서, 서로 다른 것의 개수를 구해봤을 때, 가장 1의 수가 작은 것이 이 코드워드의 해밍 디스턴스가 됨.
--> 그래서 기저가 되는 G가 1이 가장 작은 codeword임.
	G의 해밍 디스턴스는 위에서부터 3,3,4,3 인데 이중에서 최소가 3이므로 3.
이해하면 더좋음.
 









